package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"time"

	lawapi "go.ngs.io/jplaw-api-v2"
	model1 "go.ngs.io/jplaw2epub-web-api/graphql/model"
)

// LawNumEra is the resolver for the lawNumEra field.
func (r *lawInfoResolver) LawNumEra(ctx context.Context, obj *lawapi.LawInfo) (*model1.LawNumEra, error) {
	return convertLawNumEraToModel(obj.LawNumEra), nil
}

// LawNumType is the resolver for the lawNumType field.
func (r *lawInfoResolver) LawNumType(ctx context.Context, obj *lawapi.LawInfo) (*model1.LawNumType, error) {
	return convertLawNumTypeToModel(obj.LawNumType), nil
}

// LawType is the resolver for the lawType field.
func (r *lawInfoResolver) LawType(ctx context.Context, obj *lawapi.LawInfo) (*model1.LawType, error) {
	return convertLawTypeToModel(obj.LawType), nil
}

// PromulgationDate is the resolver for the promulgationDate field.
func (r *lawInfoResolver) PromulgationDate(ctx context.Context, obj *lawapi.LawInfo) (string, error) {
	return obj.PromulgationDate.String(), nil
}

// Laws is the resolver for the laws field.
func (r *queryResolver) Laws(ctx context.Context, lawID *string, lawNum *string, lawTitle *string, lawTitleKana *string, lawType []model1.LawType, asof *string, categoryCode []model1.CategoryCode, promulgateDateFrom *string, promulgateDateTo *string, limit *int, offset *int) (*lawapi.LawsResponse, error) {
	params := &lawapi.GetLawsParams{}

	if lawID != nil {
		params.LawId = lawID
	}
	if lawNum != nil {
		params.LawNum = lawNum
	}
	if lawTitle != nil {
		params.LawTitle = lawTitle
	}
	if lawTitleKana != nil {
		params.LawTitleKana = lawTitleKana
	}
	if len(lawType) > 0 {
		converted := convertLawType(lawType)
		params.LawType = &converted
	}
	if asof != nil {
		if t, err := time.Parse("2006-01-02", *asof); err == nil {
			date := lawapi.Date(t)
			params.Asof = &date
		}
	}
	if len(categoryCode) > 0 {
		converted := convertCategoryCode(categoryCode)
		params.CategoryCd = &converted
	}
	if promulgateDateFrom != nil {
		if t, err := time.Parse("2006-01-02", *promulgateDateFrom); err == nil {
			date := lawapi.Date(t)
			params.PromulgationDateFrom = &date
		}
	}
	if promulgateDateTo != nil {
		if t, err := time.Parse("2006-01-02", *promulgateDateTo); err == nil {
			date := lawapi.Date(t)
			params.PromulgationDateTo = &date
		}
	}
	if limit != nil {
		limit32 := int32(*limit)
		params.Limit = &limit32
	}
	if offset != nil {
		offset32 := int32(*offset)
		params.Offset = &offset32
	}

	return r.Resolver.client.GetLaws(params)
}

// Revisions is the resolver for the revisions field.
func (r *queryResolver) Revisions(ctx context.Context, lawID string, lawTitle *string, lawTitleKana *string, amendmentLawID *string, amendmentDateFrom *string, amendmentDateTo *string, categoryCode []model1.CategoryCode, updatedFrom *string, updatedTo *string) (*lawapi.LawRevisionsResponse, error) {
	params := &lawapi.GetRevisionsParams{}

	if lawTitle != nil {
		params.LawTitle = lawTitle
	}
	if lawTitleKana != nil {
		params.LawTitleKana = lawTitleKana
	}
	if amendmentLawID != nil {
		params.AmendmentLawId = amendmentLawID
	}
	if amendmentDateFrom != nil {
		if t, err := time.Parse("2006-01-02", *amendmentDateFrom); err == nil {
			date := lawapi.Date(t)
			params.AmendmentDateFrom = &date
		}
	}
	if amendmentDateTo != nil {
		if t, err := time.Parse("2006-01-02", *amendmentDateTo); err == nil {
			date := lawapi.Date(t)
			params.AmendmentDateTo = &date
		}
	}
	if len(categoryCode) > 0 {
		converted := convertCategoryCode(categoryCode)
		params.CategoryCd = &converted
	}
	if updatedFrom != nil {
		if t, err := time.Parse("2006-01-02", *updatedFrom); err == nil {
			date := lawapi.Date(t)
			params.UpdatedFrom = &date
		}
	}
	if updatedTo != nil {
		if t, err := time.Parse("2006-01-02", *updatedTo); err == nil {
			date := lawapi.Date(t)
			params.UpdatedTo = &date
		}
	}

	return r.Resolver.client.GetRevisions(lawID, params)
}

// Keyword is the resolver for the keyword field.
func (r *queryResolver) Keyword(ctx context.Context, keyword string, lawNum *string, lawType []model1.LawType, asof *string, categoryCode []model1.CategoryCode, promulgateDateFrom *string, promulgateDateTo *string, limit *int, offset *int, sentencesLimit *int) (*lawapi.KeywordResponse, error) {
	params := &lawapi.GetKeywordParams{
		Keyword: keyword,
	}

	if lawNum != nil {
		params.LawNum = lawNum
	}
	if len(lawType) > 0 {
		converted := convertLawType(lawType)
		params.LawType = &converted
	}
	if asof != nil {
		if t, err := time.Parse("2006-01-02", *asof); err == nil {
			date := lawapi.Date(t)
			params.Asof = &date
		}
	}
	if len(categoryCode) > 0 {
		converted := convertCategoryCode(categoryCode)
		params.CategoryCd = &converted
	}
	if promulgateDateFrom != nil {
		if t, err := time.Parse("2006-01-02", *promulgateDateFrom); err == nil {
			date := lawapi.Date(t)
			params.PromulgationDateFrom = &date
		}
	}
	if promulgateDateTo != nil {
		if t, err := time.Parse("2006-01-02", *promulgateDateTo); err == nil {
			date := lawapi.Date(t)
			params.PromulgationDateTo = &date
		}
	}
	if limit != nil {
		limit32 := int32(*limit)
		params.Limit = &limit32
	}
	if offset != nil {
		offset32 := int32(*offset)
		params.Offset = &offset32
	}
	if sentencesLimit != nil {
		limit32 := int32(*sentencesLimit)
		params.SentencesLimit = &limit32
	}

	return r.Resolver.client.GetKeyword(params)
}

// LawType is the resolver for the lawType field.
func (r *revisionInfoResolver) LawType(ctx context.Context, obj *lawapi.RevisionInfo) (*model1.LawType, error) {
	return convertLawTypeToModel(obj.LawType), nil
}

// AmendmentPromulgateDate is the resolver for the amendmentPromulgateDate field.
func (r *revisionInfoResolver) AmendmentPromulgateDate(ctx context.Context, obj *lawapi.RevisionInfo) (string, error) {
	return obj.AmendmentPromulgateDate.String(), nil
}

// AmendmentEnforcementDate is the resolver for the amendmentEnforcementDate field.
func (r *revisionInfoResolver) AmendmentEnforcementDate(ctx context.Context, obj *lawapi.RevisionInfo) (string, error) {
	return obj.AmendmentEnforcementDate.String(), nil
}

// RepealDate is the resolver for the repealDate field.
func (r *revisionInfoResolver) RepealDate(ctx context.Context, obj *lawapi.RevisionInfo) (string, error) {
	return obj.RepealDate.String(), nil
}

// Updated is the resolver for the updated field.
func (r *revisionInfoResolver) Updated(ctx context.Context, obj *lawapi.RevisionInfo) (string, error) {
	return obj.Updated.String(), nil
}

// CurrentRevisionStatus is the resolver for the currentRevisionStatus field.
func (r *revisionInfoResolver) CurrentRevisionStatus(ctx context.Context, obj *lawapi.RevisionInfo) (*model1.CurrentRevisionStatus, error) {
	return convertCurrentRevisionStatusToModel(obj.CurrentRevisionStatus), nil
}

// RepealStatus is the resolver for the repealStatus field.
func (r *revisionInfoResolver) RepealStatus(ctx context.Context, obj *lawapi.RevisionInfo) (*model1.RepealStatus, error) {
	return convertRepealStatusToModel(obj.RepealStatus), nil
}

// Mission is the resolver for the mission field.
func (r *revisionInfoResolver) Mission(ctx context.Context, obj *lawapi.RevisionInfo) (*model1.Mission, error) {
	return convertMissionToModel(obj.Mission), nil
}

// LawInfo returns LawInfoResolver implementation.
func (r *Resolver) LawInfo() LawInfoResolver { return &lawInfoResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// RevisionInfo returns RevisionInfoResolver implementation.
func (r *Resolver) RevisionInfo() RevisionInfoResolver { return &revisionInfoResolver{r} }

type lawInfoResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type revisionInfoResolver struct{ *Resolver }
